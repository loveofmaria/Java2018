### 多线程



#### 基本概念： 程序、进程、线程

*   **程序**[Program] - 为了完成特定任务、用某种语言编写的一组指令的集合

*   **进程**[ process ] - 是程序的一次执行过程，或是正在运行的一个程序。

    进程是一个动态的过程：有自生的产生、存在和消亡的过程 —— 生命周期

    *   比如：运行中的QQ，运行中的播放器等等
    *   程序是静态的，进程是动态的
    *   进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域

*   线**程**[ thread ] - 进程可进一步细化为线程，是一个程序内部的一条执行路径

    若一个进程同一时间并行执行多个线程，就是支持多线程的

    线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器[ PC ]，线程切换的开销小

    一个进程中的多个线程共享相同的内存单元/内存地址空间 -» 它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能会带来安全隐患

    单核CPU和多核CPU

    单核是一种假的多线程

    多核才能更好的发挥多线程效率

    一个Java的应用程序至少有3个线程：主线程main()  垃圾回收线程 gc()  异常处理线程

*   **并行和并发**

    *   并行：多个CPU同时执行多个任务
    *   并发：一个CPU「采用时间片」同时执行多个任务

*   **使用多线程的优点**

    *   提高应用程序相应，对图形化界面更有意义，可增强用户体验
    *   提高计算机系统CPU的利用率
    *   改善程序结构，将既长又复杂的进程分为多个线程，独立运行，利于理解和修改

*   **需要创建多线程的场景**

    *   程序需要同时执行两个或多个任务
    *   程序需要实现一些需要等待的任务时，如果用户输入、文件读写操作、网络操作、搜索等等
    *   需要一些后台运行的程序时

#### 线程的创建和使用

*   Java语言的JVM允许程序运行多个线程，它通过`java.lang.Thread`类来体现

*   **Thread类的特征**

    *   每个线程都是通过某个特定的Thread对象的run()方法来完成操作，经常把run()方法的主体称为线程体
    *   通过Thread对象的start()方法来启动这个线程，而非直接调用run()

*   **创建方式**「两种」:

    *   方式一：

        1.  继承Thread类
        2.  重写Thread类的run()方法 —> 此线程将要执行的操作写在该方法中
        3.  创建Thread类子类的对象
        4.  通过子类的实例对象调用start()方法
        5.  不能通过调用run()方法来创建线程；一个线程不能同时多次开启「除非创建一个新的线程」

    *   方式二:

        ```java
        //匿名类的形式创建
        new Thread(){
            @Override
            public void run() {
                // do something here
            }
        }.start();
        ```

*   **Thread类的常用方法:**

    *   void start() -> 启动线程，并执行 run( ) 方法

    *   run() -> 线程在被调度时执行的操作

    *   String getName() -> 返回线程的名称

    *   void setName(String name) -> 设置当前线程的名称, 

        或者直接使用构造器+name参数 subThread("子进程")

        ```java
        class SubThread extends Thread {
            SubThread(String name) {
                super(name);
            }
            @Override
            public void run () {
                // dosomething here
            }
        }
        ```

        

    *   static Thread currentThread() -> 返回当前线程，在Thread子类中就是 this, 通常用于主线程和Runnable实现类

    *   static void yield() -> 线程让步

        *   暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程
        *   若队列中没有同优先级的线程，忽略此方法

    *   join() -> 当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到join()方法加入的join线程执行完成为止

        *   低优先级的线程也可以获得执行

    *   static void sleep(long millis) -> 指定自定义阻塞时间[毫秒]

        *   令当前活动线程在指定时间段内放弃对CPU控制，使其他线程有机会被执行，时间到后重排队；
        *   抛出InterruptedException 异常

    *   stop() -> 强制线程生命期结束，不推荐使用

    *   boolean isAlive() -> 判断线程是否还存活

*   **线程的调度**

    *   调度策略 : 时间片  抢占式「高优先级的线程抢占CPU」
    *   Java的调度方法:
        1.  同优先级的线程组成先进先出队列「先到先服务」，使用时间片策略
        2.  对高优先级，使用优先调度的抢占式策略
    *   线程优先级
        *   线程的优先级等级
            *   MAX_PRIORITY: 10
            *   MIN_PRIORITY: 1
            *   NORM_PRIORITY: 5
        *   涉及的方法
            *   getPriority( ) 返回线程优先值
            *   setPriority(int newPriority) 改变线程的优先级
        *   说明
            *   线程创建时继承父线程的优先级
            *   低优先级只是获得调度的概率低，并非一定是在高优先级线程后才被调用

#### 线程的生命周期



#### 线程的同步



#### 线程的通信



#### 新增线程创建方式「 JDK5.0后新增 」

